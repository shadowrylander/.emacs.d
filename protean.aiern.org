#+setupfile: ./settings/TANGLE.org
#+include: ./settings/README.org

* init.el
:PROPERTIES:
:header-args:emacs-lisp+: :noweb-ref init.el :tangle no
:header-args:org+: :tangle no
:END:

The ~noweb-ref~ headers, such as the one below, are adapted from [[https://emacs.stackexchange.com/users/388/melioratus][Melioratus's]] answer [[https://emacs.stackexchange.com/a/38935/31428][here]].
This way, I can maintain some semblance of a literate config.

#+begin_src org
,#+begin_src emacs-lisp :noweb-ref no :tangle (meq/tangle-path)
#+end_src

#+begin_src emacs-lisp :noweb-ref no :tangle (meq/tangle-path)
<<init.el>>
#+end_src

#+begin_src org
,#+end_src
#+end_src

If the version of emacs we're running is less than ~27~, call ~init.el~ manually:

#+begin_src emacs-lisp
;;; $EMACSDIR/init.el -*- lexical-binding: t; -*-
(when (version< emacs-version "27") (load (concat (file-name-directory load-file-name) "early-init.el")))
#+end_src

Finally, create the function to [re]load the primary init in this file and load it for the first time:

#+begin_src emacs-lisp
(defun meq/reload-first-init nil (interactive) (meq/cl (meq/ued "protean.aiern.org")))
(meq/reload-first-init)
#+end_src

* EXWM
:PROPERTIES:
:header-args:emacs-lisp+: :tangle yes
:END:

This sets up and requires the [[https://github.com/ch11ng/exwm][Emacs X Window Manager]] by
[[https://github.com/ch11ng][Chris Feng]], if necessary, with help from [[https://emacs.stackexchange.com/a/60455/31428][this answer]] by [[https://emacs.stackexchange.com/users/418/gregoryg][gregoryg]]:

#+begin_src emacs-lisp
(defvar meq/var/exwm nil)
(when (get-buffer "*window-manager*")
  (kill-buffer "*window-manager*"))
(when (get-buffer "*window-manager-error*")
  (kill-buffer "*window-manager-error*"))
(when (executable-find "wmctrl")
  (shell-command "wmctrl -m ; echo $?" "*window-manager*" "*window-manager-error*"))

  ;; if there was an error detecting the window manager, initialize EXWM
  (when (and (get-buffer "*window-manager-error*")
             (eq window-system 'x))
    ;; exwm startup goes here
    (setq meq/var/exwm t))
(meq/up exwm :if meq/var/exwm
#+end_src

I want to run the following applications on ~EXWM~ startup:
- [[https://github.com/alacritty/alacritty][Alacritty]]
- [[https://obsidian.md/][Obsidian]]

#+begin_src emacs-lisp
    :init/defun* (post-exwm nil (interactive)
                (unless (get-buffer "Alacritty") (meq/run "alacritty"))
                (unless (get-buffer "obsidian") (meq/run "obsidian")))
    :hook (exwm-init . #'post-exwm)
#+end_src

Load the ~fringe~ package and
[[https://github.com/lujun9972/el-dmenu/blob/e8cc9b27c79d3ecc252267c082ab8e9c82eab264/dmenu.el][dmenu]]:

#+begin_src emacs-lisp
    :upnsd-preconfig (dmenu) (fringe :config
                        ;; (fringe-mode (quote (1 . 1)) nil (fringe))
                        ;; (fringe-mode '(3 . 0))
                        ;; (fringe-mode 'none)
                        ;; (fringe-mode 1)
                        )
#+end_src

#+begin_src emacs-lisp
    :config
        (require 'scroll-bar)
        ;; Adapted From: https://github.com/ch11ng/exwm/blob/master/exwm-config.el#L34
        (require 'exwm-config)
        ;; Set the initial workspace number.
        (unless (get 'exwm-workspace-number 'saved-value)
            (setq exwm-workspace-number 4))
        ;; Make class name the buffer name
        (add-hook 'exwm-update-class-hook #'(lambda nil (interactive)
                    (exwm-workspace-rename-buffer exwm-class-name)))
        ;; Global keybindings.
        (unless (get 'exwm-input-global-keys 'saved-value)
            (setq exwm-input-global-keys
                `(
#+end_src

These keybindings will run my major-mode-based deino, i.e. the ~exwm-global~ deino in this case:

#+begin_src emacs-lisp
                    ([?\s-p] . uru)
                    ([?\s-`] . uru)
                    ([?\s-z] . uru)
#+end_src

Switch buffers quickly:

#+begin_src emacs-lisp
                    (,(naked "s-tab") . next-buffer)
                    (,(naked "s-<iso-lefttab>") . previous-buffer)
                    (,(naked "M-s-tab") . previous-buffer)
#+end_src

~[s]uper-q~ will activate my buffer deino:

#+begin_src emacs-lisp
                    ([?\s-q] . deino-buffer/body)
#+end_src

#+begin_src emacs-lisp
                    ;; 's-N': Switch to certain workspace.
                    ,@(mapcar (lambda (i)
                                `(,(kbd (format "s-%d" i)) .
                                (lambda ()
                                    (interactive)
                                    (exwm-workspace-switch-create ,i))))
                            (number-sequence 0 9)))))
        ;; Line-editing shortcuts
        (unless (get 'exwm-input-simulation-keys 'saved-value)
            (setq exwm-input-simulation-keys
                '(([?\C-b] . [left])
                    ([?\C-f] . [right])
                    ([?\C-p] . [up])
                    ([?\C-n] . [down])
                    ([?\C-a] . [home])
                    ([?\C-e] . [end])
                    ([?\M-v] . [prior])
                    ([?\C-v] . [next])
                    ([?\C-d] . [delete])
                    ([?\C-k] . [S-end delete]))))

        (exwm-enable)
        ;; Configure Ido
        (exwm-config-ido)
        ;; Other configurations
        (exwm-config-misc)

        ;; (exwm-config-default)
        ;; (exwm-enable)

    :which-key-change-ryo ("e" "exwm" 'exwm-init-hook)
#+end_src

Here's the global ~exwm~ deino, triggered by [[https://github.com/shadowrylander/uru][uru]]:

#+begin_src emacs-lisp
    :uru (exwm-mode t deino-exwm-global (:color blue) "e g"
            ("`" nil "cancel")
            ("c" exwm-input-release-keyboard "char mode")
            ("l" exwm-input-grab-keyboard "line mode")
            ("r" exwm-reset "reset")
            ("w" exwm-workspace-switch "workspace switch")
            ("i" meq/run-interactive "run")
            ("b" deino-buffer/body "buffers"))
#+end_src

This is my general ~exwm~ deino, leading to all the other ~exwm~ deinos:

#+begin_src emacs-lisp
    :deino (deino-exwm nil "e e"
            ("`" nil "cancel")
            ("XF86PowerOff" deino-exwm/power/body "power")
            ("s" deino-exwm/shells/body "shells"))
#+end_src

I can reboot, power off, and suspend using this one:

#+begin_src emacs-lisp
        (deino-exwm/power (:color blue) "e p"
            ("r" (meq/run "reboot") "reboot")
            ("q" (meq/run "poweroff") "poweroff")
            ("XF86PowerOff" (meq/run "systemctl suspend" "suspend") "suspend"))
#+end_src

And run my shells and terminals using this one:

#+begin_src emacs-lisp
        (deino-exwm/shells (:color blue) "e s" ("a" (meq/run "alacritty") "alacritty"))
#+end_src

I use the power button to trigger the general ~exwm~ deino:

#+begin_src emacs-lisp
    :demon ((naked "XF86PowerOff") 'deino-exwm/body)
#+end_src

And finally: no tiling:

#+begin_src emacs-lisp
    :gsetq (exwm-manage-force-tiling t)
        ;; Adapted From: https://www.reddit.com/r/emacs/comments/8yf6dx/key_chords_in_exwm/
        ;; (exwm-input-line-mode-passthrough t)
)
#+end_src

* Startup
:PROPERTIES:
:header-args:emacs-lisp+: :tangle yes
:END:

#+begin_src emacs-lisp
(when (> (length command-line-args) 1) (let* ((last-dab (car (last command-line-args))))
                                            (defvar meq/var/last-dab last-dab)
                                            (delete last-dab command-line-args)))
(let* ((testing (meq/ued "testing.aiern.org"))
        (resting (meq/ued "resting.aiern.org"))
        (early-init (meq/ued "early-init.org"))
        (init (meq/ued "init.org"))
        (early-aiern-init (meq/ued "early-init.aiern.org"))
        (aiern-init (meq/ued "init.aiern.org")))
    (if (bound-and-true-p meq/var/last-dab)
        (pcase meq/var/last-dab
            ("--fTest" (setq initial-buffer-choice testing))
            ("--fRest" (setq initial-buffer-choice resting))
            ("--fEarly" (setq initial-buffer-choice early-init))
            ("--fAEarly" (setq initial-buffer-choice early-aiern-init))
            ("--fInit" (setq initial-buffer-choice init))
            ("--fAInit" (setq initial-buffer-choice aiern-init))
            (t (setq initial-buffer-choice (f-full meq/var/last-dab))))
        (setq initial-buffer-choice testing))
    (eval `(add-hook 'kill-emacs-hook #'(lambda nil (interactive)
        ;; Adapted From: http://ergoemacs.org/emacs/elisp_file_name_dir_name.html
        (when (get-file-buffer ,testing) (delete-file ,testing) (copy-file ,resting ,testing))))))
#+end_src
